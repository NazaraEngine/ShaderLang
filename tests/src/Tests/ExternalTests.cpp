#include <Tests/ShaderUtils.hpp>
#include <NZSL/ShaderBuilder.hpp>
#include <NZSL/Parser.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers.hpp>
#include <cctype>

TEST_CASE("external", "[Shader]")
{
	SECTION("Texture 2D")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

external
{
	[tag("Color map")]
	[binding(0)] tex: sampler2D[f32]
}

[entry(frag)]
fn main()
{
	let value = tex.Sample(vec2[f32](0.0, 0.0));
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// fragment shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
precision highp sampler2D;
#else
precision mediump float;
precision mediump sampler2D;
#endif

// header end

// external var tag: Color map
uniform sampler2D tex;

void main()
{
	vec4 value = texture(tex, vec2(0.0, 0.0));
}
)");

		ExpectNZSL(*shaderModule, R"(
external
{
	[set(0), binding(0), tag("Color map")] tex: sampler2D[f32]
}

[entry(frag)]
fn main()
{
	let value: vec4[f32] = tex.Sample(vec2[f32](0.0, 0.0));
})");

		ExpectSPIRV(*shaderModule, R"(
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 0 0 0 1 ImageFormat(Unknown)
 %3 = OpTypeSampledImage %2
 %4 = OpTypePointer StorageClass(UniformConstant) %3
 %6 = OpTypeVoid
 %7 = OpTypeFunction %6
 %8 = OpConstant %1 f32(0)
 %9 = OpTypeVector %1 2
%10 = OpTypeVector %1 4
%11 = OpTypePointer StorageClass(Function) %10
 %5 = OpVariable %4 StorageClass(UniformConstant)
%12 = OpFunction %6 FunctionControl(0) %7
%13 = OpLabel
%14 = OpVariable %11 StorageClass(Function)
%15 = OpLoad %3 %5
%16 = OpCompositeConstruct %9 %8 %8
%17 = OpImageSampleImplicitLod %10 %15 %16
      OpStore %14 %17
      OpReturn
      OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
// Tag: Color map
@group(0) @binding(0) var tex: texture_2d<f32>;
@group(0) @binding(1) var texSampler: sampler;

@fragment
fn main()
{
	var value: vec4<f32> = textureSample(tex, texSampler, vec2<f32>(0.0, 0.0));
}
)");
	}

	SECTION("Arrays of texture")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

external
{
	[binding(0)] tex: array[sampler_cube[f32], 5]
}

[entry(frag)]
fn main()
{
	let value = tex[2].Sample(vec3[f32](0.0, 0.0, 0.0));
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// fragment shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
precision highp samplerCube;
#else
precision mediump float;
precision mediump samplerCube;
#endif

// header end

uniform samplerCube tex[5];

void main()
{
	vec4 value = texture(tex[2], vec3(0.0, 0.0, 0.0));
}
)");

		ExpectNZSL(*shaderModule, R"(
external
{
	[set(0), binding(0)] tex: array[sampler_cube[f32], 5]
}

[entry(frag)]
fn main()
{
	let value: vec4[f32] = tex[2].Sample(vec3[f32](0.0, 0.0, 0.0));
})");

		ExpectSPIRV(*shaderModule, R"(
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Cube) 0 0 0 1 ImageFormat(Unknown)
 %3 = OpTypeSampledImage %2
 %4 = OpTypeInt 32 0
 %5 = OpConstant %4 u32(5)
 %6 = OpTypeArray %3 %5
 %7 = OpTypePointer StorageClass(UniformConstant) %6
 %9 = OpTypeVoid
%10 = OpTypeFunction %9
%11 = OpTypeInt 32 1
%12 = OpConstant %11 i32(2)
%13 = OpConstant %1 f32(0)
%14 = OpTypeVector %1 3
%15 = OpTypeVector %1 4
%16 = OpTypePointer StorageClass(Function) %15
%20 = OpTypePointer StorageClass(UniformConstant) %3
 %8 = OpVariable %7 StorageClass(UniformConstant)
%17 = OpFunction %9 FunctionControl(0) %10
%18 = OpLabel
%19 = OpVariable %16 StorageClass(Function)
%21 = OpAccessChain %20 %8 %12
%22 = OpLoad %3 %21
%23 = OpCompositeConstruct %14 %13 %13 %13
%24 = OpImageSampleImplicitLod %15 %22 %23
      OpStore %19 %24
      OpReturn
      OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
@group(0) @binding(0) var tex: binding_array<texture_cube<f32>, 5>;
@group(0) @binding(1) var texSampler: sampler;

@fragment
fn main()
{
	var value: vec4<f32> = textureSample(tex[2], texSampler, vec3<f32>(0.0, 0.0, 0.0));
})");
	}

	SECTION("Uniform buffers")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[tag("DataStruct")]
struct Data
{
	[tag("Values")]
	values: array[f32, 47],
	matrices: array[mat4[f32], 3]
}

external
{
	[binding(0)] data: uniform[Data]
}

[entry(frag)]
fn main()
{
	let value = data.values[42] * data.matrices[1];
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// struct tag: DataStruct
uniform _nzslBindingdata
{
	// member tag: Values
	float values[47];
	mat4 matrices[3];
} data;

void main()
{
	mat4 value = data.values[42] * data.matrices[1];
}
)");

		ExpectNZSL(*shaderModule, R"(
[tag("DataStruct")]
struct Data
{
	[tag("Values")] values: array[f32, 47],
	matrices: array[mat4[f32], 3]
}

external
{
	[set(0), binding(0)] data: uniform[Data]
}

[entry(frag)]
fn main()
{
	let value: mat4[f32] = data.values[42] * data.matrices[1];
})");

		ExpectSPIRV(*shaderModule, R"(
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %9 "Data"
      OpMemberName %9 0 "values"
      OpMemberName %9 1 "matrices"
      OpName %11 "data"
      OpName %21 "main"
      OpDecorate %11 Decoration(Binding) 0
      OpDecorate %11 Decoration(DescriptorSet) 0
      OpDecorate %4 Decoration(ArrayStride) 16
      OpDecorate %8 Decoration(ArrayStride) 64
      OpDecorate %9 Decoration(Block)
      OpMemberDecorate %9 0 Decoration(Offset) 0
      OpMemberDecorate %9 1 Decoration(ColMajor)
      OpMemberDecorate %9 1 Decoration(MatrixStride) 16
      OpMemberDecorate %9 1 Decoration(Offset) 752
 %1 = OpTypeFloat 32
 %2 = OpTypeInt 32 0
 %3 = OpConstant %2 u32(47)
 %4 = OpTypeArray %1 %3
 %5 = OpTypeVector %1 4
 %6 = OpTypeMatrix %5 4
 %7 = OpConstant %2 u32(3)
 %8 = OpTypeArray %6 %7
 %9 = OpTypeStruct %4 %8
%10 = OpTypePointer StorageClass(Uniform) %9
%12 = OpTypeVoid
%13 = OpTypeFunction %12
%14 = OpTypeInt 32 1
%15 = OpConstant %14 i32(0)
%16 = OpTypeArray %1 %3
%17 = OpConstant %14 i32(42)
%18 = OpConstant %14 i32(1)
%19 = OpTypeArray %6 %7
%20 = OpTypePointer StorageClass(Function) %6
%24 = OpTypePointer StorageClass(Uniform) %1
%27 = OpTypePointer StorageClass(Uniform) %6
%11 = OpVariable %10 StorageClass(Uniform)
%21 = OpFunction %12 FunctionControl(0) %13
%22 = OpLabel
%23 = OpVariable %20 StorageClass(Function)
%25 = OpAccessChain %24 %11 %15 %17
%26 = OpLoad %1 %25
%28 = OpAccessChain %27 %11 %18 %18
%29 = OpLoad %6 %28
%30 = OpMatrixTimesScalar %6 %29 %26
      OpStore %23 %30
      OpReturn
      OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
struct f32_stride16
{
	value: f32,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32
}

// Tag: DataStruct

// std140 layout
struct Data
{
	// Tag: Values
	 values: array<f32_stride16, 47>,
	matrices: array<mat4x4<f32>, 3>,
	_padding0: f32
}

@group(0) @binding(0) var<uniform> data: Data;

@fragment
fn main()
{
	var value: mat4x4<f32> = data.values[42].value * data.matrices[1];
}
)");
	}

	SECTION("Storage buffers")
	{
		SECTION("With fixed-size array")
		{
			std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[layout(std430)]
struct Data
{
	values: array[f32, 47]
}

external
{
	[set(0), binding(0)] inData: storage[Data, readonly],
	[set(0), binding(1)] outData: storage[Data, writeonly]
}

[entry(frag)]
fn main()
{
	for i in 0 -> 47
		outData.values[i] = inData.values[i];
}
)";

			nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
			ResolveModule(*shaderModule);

			nzsl::GlslWriter::Environment glslEnv;
			glslEnv.glMajorVersion = 3;
			glslEnv.glMinorVersion = 1;

			ExpectGLSL(*shaderModule, R"(
layout(std430) readonly buffer _nzslBindinginData
{
	float values[47];
} inData;

layout(std430) writeonly buffer _nzslBindingoutData
{
	float values[47];
} outData;

void main()
{
	{
		int i = 0;
		int _nzsl_to = 47;
		while (i < _nzsl_to)
		{
			outData.values[i] = inData.values[i];
			i += 1;
		}

	}

}
)", {}, glslEnv);

			ExpectNZSL(*shaderModule, R"(
[layout(std430)]
struct Data
{
	values: array[f32, 47]
}

external
{
	[set(0), binding(0)] inData: storage[Data, readonly],
	[set(0), binding(1)] outData: storage[Data, writeonly]
}

[entry(frag)]
fn main()
{
	for i in 0 -> 47
	{
		outData.values[i] = inData.values[i];
	}

})");

			WHEN("Generating SPIR-V 1.0")
			{
				nzsl::SpirvWriter::Environment spirvEnv;
				ExpectSPIRV(*shaderModule, R"(
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %5 "Data"
      OpMemberName %5 0 "values"
      OpName %7 "inData"
      OpName %8 "outData"
      OpName %18 "main"
      OpDecorate %7 Decoration(NonWritable)
      OpDecorate %7 Decoration(Binding) 0
      OpDecorate %7 Decoration(DescriptorSet) 0
      OpDecorate %8 Decoration(NonReadable)
      OpDecorate %8 Decoration(Binding) 1
      OpDecorate %8 Decoration(DescriptorSet) 0
      OpDecorate %4 Decoration(ArrayStride) 4
      OpDecorate %5 Decoration(BufferBlock)
      OpMemberDecorate %5 0 Decoration(Offset) 0
 %1 = OpTypeFloat 32
 %2 = OpTypeInt 32 0
 %3 = OpConstant %2 u32(47)
 %4 = OpTypeArray %1 %3
 %5 = OpTypeStruct %4
 %6 = OpTypePointer StorageClass(Uniform) %5
 %9 = OpTypeVoid
%10 = OpTypeFunction %9
%11 = OpTypeInt 32 1
%12 = OpConstant %11 i32(0)
%13 = OpTypePointer StorageClass(Function) %11
%14 = OpConstant %11 i32(47)
%15 = OpTypeBool
%16 = OpTypeArray %1 %3
%17 = OpConstant %11 i32(1)
%30 = OpTypePointer StorageClass(Uniform) %1
%34 = OpTypePointer StorageClass(Uniform) %4
 %7 = OpVariable %6 StorageClass(Uniform)
 %8 = OpVariable %6 StorageClass(Uniform)
%18 = OpFunction %9 FunctionControl(0) %10
%19 = OpLabel
%20 = OpVariable %13 StorageClass(Function)
%21 = OpVariable %13 StorageClass(Function)
      OpStore %20 %12
      OpStore %21 %14
      OpBranch %22
%22 = OpLabel
%26 = OpLoad %11 %20
%27 = OpLoad %11 %21
%28 = OpSLessThan %15 %26 %27
      OpLoopMerge %24 %25 LoopControl(0)
      OpBranchConditional %28 %23 %24
%23 = OpLabel
%29 = OpLoad %11 %20
%31 = OpAccessChain %30 %7 %12 %29
%32 = OpLoad %1 %31
%33 = OpAccessChain %34 %8 %12
%35 = OpLoad %11 %20
%36 = OpAccessChain %30 %33 %35
      OpStore %36 %32
%37 = OpLoad %11 %20
%38 = OpIAdd %11 %37 %17
      OpStore %20 %38
      OpBranch %25
%25 = OpLabel
      OpBranch %22
%24 = OpLabel
      OpReturn
      OpFunctionEnd)", {}, spirvEnv, true);

			ExpectWGSL(*shaderModule, R"(
struct Data
{
	values: array<f32, 47>
}

@group(0) @binding(0) var<storage, read> inData: Data;
@group(0) @binding(1) var<storage, read_write> outData: Data;

@fragment
fn main()
{
	{
		var i: i32 = 0;
		var _nzsl_to: i32 = 47;
		while (i < _nzsl_to)
		{
			outData.values[i] = inData.values[i];
			i += 1;
		}

	}

})");
			}

			WHEN("Generating SPIR-V 1.3")
			{
				nzsl::SpirvWriter::Environment spirvEnv;
				spirvEnv.spvMajorVersion = 1;
				spirvEnv.spvMinorVersion = 3;

				ExpectSPIRV(*shaderModule, R"(
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %5 "Data"
      OpMemberName %5 0 "values"
      OpName %7 "inData"
      OpName %8 "outData"
      OpName %18 "main"
      OpDecorate %7 Decoration(NonWritable)
      OpDecorate %7 Decoration(Binding) 0
      OpDecorate %7 Decoration(DescriptorSet) 0
      OpDecorate %8 Decoration(NonReadable)
      OpDecorate %8 Decoration(Binding) 1
      OpDecorate %8 Decoration(DescriptorSet) 0
      OpDecorate %4 Decoration(ArrayStride) 4
      OpDecorate %5 Decoration(Block)
      OpMemberDecorate %5 0 Decoration(Offset) 0
 %1 = OpTypeFloat 32
 %2 = OpTypeInt 32 0
 %3 = OpConstant %2 u32(47)
 %4 = OpTypeArray %1 %3
 %5 = OpTypeStruct %4
 %6 = OpTypePointer StorageClass(StorageBuffer) %5
 %9 = OpTypeVoid
%10 = OpTypeFunction %9
%11 = OpTypeInt 32 1
%12 = OpConstant %11 i32(0)
%13 = OpTypePointer StorageClass(Function) %11
%14 = OpConstant %11 i32(47)
%15 = OpTypeBool
%16 = OpTypeArray %1 %3
%17 = OpConstant %11 i32(1)
%30 = OpTypePointer StorageClass(StorageBuffer) %1
%34 = OpTypePointer StorageClass(StorageBuffer) %4
 %7 = OpVariable %6 StorageClass(StorageBuffer)
 %8 = OpVariable %6 StorageClass(StorageBuffer)
%18 = OpFunction %9 FunctionControl(0) %10
%19 = OpLabel
%20 = OpVariable %13 StorageClass(Function)
%21 = OpVariable %13 StorageClass(Function)
      OpStore %20 %12
      OpStore %21 %14
      OpBranch %22
%22 = OpLabel
%26 = OpLoad %11 %20
%27 = OpLoad %11 %21
%28 = OpSLessThan %15 %26 %27
      OpLoopMerge %24 %25 LoopControl(0)
      OpBranchConditional %28 %23 %24
%23 = OpLabel
%29 = OpLoad %11 %20
%31 = OpAccessChain %30 %7 %12 %29
%32 = OpLoad %1 %31
%33 = OpAccessChain %34 %8 %12
%35 = OpLoad %11 %20
%36 = OpAccessChain %30 %33 %35
      OpStore %36 %32
%37 = OpLoad %11 %20
%38 = OpIAdd %11 %37 %17
      OpStore %20 %38
      OpBranch %25
%25 = OpLabel
      OpBranch %22
%24 = OpLabel
      OpReturn
      OpFunctionEnd)", {}, spirvEnv, true);
			}
		}
		
		SECTION("With dynamically sized arrays")
		{
			std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[layout(std430)]
struct Data
{
	data: u32,
	values: dyn_array[f32]
}

external
{
	[binding(0)] data: storage[Data]
}

[entry(frag)]
fn main()
{
	let value = data.values[42];
	let size = data.values.Size();
}
)";

			nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
			ResolveModule(*shaderModule);

			nzsl::GlslWriter::Environment glslEnv;
			glslEnv.glMajorVersion = 3;
			glslEnv.glMinorVersion = 1;

			ExpectGLSL(*shaderModule, R"(
layout(std430) buffer _nzslBindingdata
{
	uint data;
	float values[];
} data;

void main()
{
	float value = data.values[42];
	uint size = uint(data.values.length());
}
)", {}, glslEnv);

			ExpectNZSL(*shaderModule, R"(
[layout(std430)]
struct Data
{
	data: u32,
	values: dyn_array[f32]
}

external
{
	[set(0), binding(0)] data: storage[Data]
}

[entry(frag)]
fn main()
{
	let value: f32 = data.values[42];
	let size: u32 = data.values.Size();
})");

			WHEN("Generating SPIR-V 1.0")
			{
				nzsl::SpirvWriter::Environment spirvEnv;

				ExpectSPIRV(*shaderModule, R"(
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %4 "Data"
      OpMemberName %4 0 "data"
      OpMemberName %4 1 "values"
      OpName %6 "data"
      OpName %15 "main"
      OpDecorate %6 Decoration(Binding) 0
      OpDecorate %6 Decoration(DescriptorSet) 0
      OpDecorate %3 Decoration(ArrayStride) 4
      OpDecorate %4 Decoration(BufferBlock)
      OpMemberDecorate %4 0 Decoration(Offset) 0
      OpMemberDecorate %4 1 Decoration(Offset) 4
 %1 = OpTypeInt 32 0
 %2 = OpTypeFloat 32
 %3 = OpTypeRuntimeArray %2
 %4 = OpTypeStruct %1 %3
 %5 = OpTypePointer StorageClass(Uniform) %4
 %7 = OpTypeVoid
 %8 = OpTypeFunction %7
 %9 = OpTypeInt 32 1
%10 = OpConstant %9 i32(1)
%11 = OpTypeRuntimeArray %2
%12 = OpConstant %9 i32(42)
%13 = OpTypePointer StorageClass(Function) %2
%14 = OpTypePointer StorageClass(Function) %1
%19 = OpTypePointer StorageClass(Uniform) %2
 %6 = OpVariable %5 StorageClass(Uniform)
%15 = OpFunction %7 FunctionControl(0) %8
%16 = OpLabel
%17 = OpVariable %13 StorageClass(Function)
%18 = OpVariable %14 StorageClass(Function)
%20 = OpAccessChain %19 %6 %10 %12
%21 = OpLoad %2 %20
      OpStore %17 %21
%22 = OpArrayLength %1 %6 1
      OpStore %18 %22
      OpReturn
      OpFunctionEnd)", {}, spirvEnv, true);
			}

			WHEN("Generating SPIR-V 1.3")
			{
				nzsl::SpirvWriter::Environment spirvEnv;
				spirvEnv.spvMajorVersion = 1;
				spirvEnv.spvMinorVersion = 3;

				ExpectSPIRV(*shaderModule, R"(
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %4 "Data"
      OpMemberName %4 0 "data"
      OpMemberName %4 1 "values"
      OpName %6 "data"
      OpName %15 "main"
      OpDecorate %6 Decoration(Binding) 0
      OpDecorate %6 Decoration(DescriptorSet) 0
      OpDecorate %3 Decoration(ArrayStride) 4
      OpDecorate %4 Decoration(Block)
      OpMemberDecorate %4 0 Decoration(Offset) 0
      OpMemberDecorate %4 1 Decoration(Offset) 4
 %1 = OpTypeInt 32 0
 %2 = OpTypeFloat 32
 %3 = OpTypeRuntimeArray %2
 %4 = OpTypeStruct %1 %3
 %5 = OpTypePointer StorageClass(StorageBuffer) %4
 %7 = OpTypeVoid
 %8 = OpTypeFunction %7
 %9 = OpTypeInt 32 1
%10 = OpConstant %9 i32(1)
%11 = OpTypeRuntimeArray %2
%12 = OpConstant %9 i32(42)
%13 = OpTypePointer StorageClass(Function) %2
%14 = OpTypePointer StorageClass(Function) %1
%19 = OpTypePointer StorageClass(StorageBuffer) %2
 %6 = OpVariable %5 StorageClass(StorageBuffer)
%15 = OpFunction %7 FunctionControl(0) %8
%16 = OpLabel
%17 = OpVariable %13 StorageClass(Function)
%18 = OpVariable %14 StorageClass(Function)
%20 = OpAccessChain %19 %6 %10 %12
%21 = OpLoad %2 %20
      OpStore %17 %21
%22 = OpArrayLength %1 %6 1
      OpStore %18 %22
      OpReturn
      OpFunctionEnd)", {}, spirvEnv, true);
			}

			ExpectWGSL(*shaderModule, R"(
struct Data
{
	data: u32,
	values: array<f32>
}

@group(0) @binding(0) var<storage, read_write> data: Data;

@fragment
fn main()
{
	var value: f32 = data.values[42];
	var size: u32 = arrayLength(&data.values);
}
)");
		}
	}

	SECTION("Primitive external")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
[feature(primitive_externals)]
module;

[tag("External set tag")]
external
{
	[tag("Scalars")]
	[binding(0)] bVal: bool,
	[binding(1)] fVal: f32,
	[binding(2)] iVal: i32,
	[binding(3)] uVal: u32,

	[tag("Vectors")]
	[binding(4)] bVec: vec4[bool],
	[binding(5)] fVec: vec4[f32],
	[binding(6)] iVec: vec4[i32],
	[binding(7)] uVec: vec4[u32],

	[tag("Matrices")]
	[binding(8)] fMat: mat4[f32],

	[tag("Arrays of matrices")]
	[binding(9)] fArrayOfMat: array[mat4[f32], 5]
}

[entry(frag)]
fn main()
{
	let value: bool = bVec[1] && bVal;
	let value: vec4[f32] = fVal * fVec;
	let value: vec4[i32] = iVal.xxxx + iVec;
	let value: vec4[u32] = uVal.xxxx - uVec;
	let value: vec4[f32] = fMat * fVec;
	let value: vec4[f32] = fArrayOfMat[2] * fVec;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// external block tag: External set tag
// external var tag: Scalars
uniform bool bVal;
uniform float fVal;
uniform int iVal;
uniform uint uVal;
// external var tag: Vectors
uniform bvec4 bVec;
uniform vec4 fVec;
uniform ivec4 iVec;
uniform uvec4 uVec;
// external var tag: Matrices
uniform mat4 fMat;
// external var tag: Arrays of matrices
uniform mat4 fArrayOfMat[5];

void main()
{
	bool value = bVec[1] && bVal;
	vec4 value_2 = fVal * fVec;
	ivec4 value_3 = (ivec4(iVal, iVal, iVal, iVal)) + iVec;
	uvec4 value_4 = (uvec4(uVal, uVal, uVal, uVal)) - uVec;
	vec4 value_5 = fMat * fVec;
	vec4 value_6 = fArrayOfMat[2] * fVec;
}
)");

		ExpectNZSL(*shaderModule, R"(
[tag("External set tag")]
external
{
	[set(0), binding(0), tag("Scalars")] bVal: bool,
	[set(0), binding(1)] fVal: f32,
	[set(0), binding(2)] iVal: i32,
	[set(0), binding(3)] uVal: u32,
	[set(0), binding(4), tag("Vectors")] bVec: vec4[bool],
	[set(0), binding(5)] fVec: vec4[f32],
	[set(0), binding(6)] iVec: vec4[i32],
	[set(0), binding(7)] uVec: vec4[u32],
	[set(0), binding(8), tag("Matrices")] fMat: mat4[f32],
	[set(0), binding(9), tag("Arrays of matrices")] fArrayOfMat: array[mat4[f32], 5]
}

[entry(frag)]
fn main()
{
	let value: bool = bVec[1] && bVal;
	let value: vec4[f32] = fVal * fVec;
	let value: vec4[i32] = (iVal.xxxx) + iVec;
	let value: vec4[u32] = (uVal.xxxx) - uVec;
	let value: vec4[f32] = fMat * fVec;
	let value: vec4[f32] = fArrayOfMat[2] * fVec;
})");

		WHEN("Generating SPIR-V 1.0 (which doesn't support primitive externals)")
		{
			nzsl::SpirvWriter spirvWriter;
			CHECK_THROWS_WITH(spirvWriter.Generate(*shaderModule), "unsupported type used in external block (SPIR-V doesn't allow primitive types as uniforms)");
		}

		WHEN("Generating WGSL (which doesn't support primitive externals)")
		{
			nzsl::WgslWriter wgslWriter;
			CHECK_THROWS_WITH(wgslWriter.Generate(*shaderModule), "primitive externals have no way to be translated in WGSL");
		}
	}


	SECTION("Auto binding generation")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

struct Foo
{
}

[auto_binding]
external
{
	tex1: sampler2D[f32],
	tex2: sampler2D[f32],
	foo : push_constant[Foo],
	[binding(4)] tex3: sampler2D[f32],
	[binding(0)] tex4: sampler2D[f32]
}

[auto_binding(true)]
external
{
	tex5: array[sampler2D[f32], 3],
	tex6: sampler_cube[f32]
}

[auto_binding(false)]
external
{
	[binding(8)] tex7: sampler2D[f32]
}

[entry(frag)]
fn main()
{
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);

		WHEN("Performing a full compilation")
		{
			ResolveModule(*shaderModule);

			ExpectNZSL(*shaderModule, R"(
struct Foo
{

}

[auto_binding(true)]
external
{
	[set(0), binding(1)] tex1: sampler2D[f32],
	[set(0), binding(2)] tex2: sampler2D[f32],
	foo: push_constant[Foo],
	[set(0), binding(4)] tex3: sampler2D[f32],
	[set(0), binding(0)] tex4: sampler2D[f32]
}

[auto_binding(true)]
external
{
	[set(0), binding(5)] tex5: array[sampler2D[f32], 3],
	[set(0), binding(3)] tex6: sampler_cube[f32]
}

[auto_binding(false)]
external
{
	[set(0), binding(8)] tex7: sampler2D[f32]
}

[entry(frag)]
fn main()
{

})");
		}

		WHEN("Performing a partial compilation")
		{
			ResolveOptions resolveOptions;
			resolveOptions.partialCompilation = true;

			ResolveModule(*shaderModule, resolveOptions);

			ExpectNZSL(*shaderModule, R"(
struct Foo
{

}

[auto_binding(true)]
external
{
	[set(0)] tex1: sampler2D[f32],
	[set(0)] tex2: sampler2D[f32],
	foo: push_constant[Foo],
	[set(0), binding(4)] tex3: sampler2D[f32],
	[set(0), binding(0)] tex4: sampler2D[f32]
}

[auto_binding(true)]
external
{
	[set(0)] tex5: array[sampler2D[f32], 3],
	[set(0)] tex6: sampler_cube[f32]
}

[auto_binding(false)]
external
{
	[set(0), binding(8)] tex7: sampler2D[f32]
}

[entry(frag)]
fn main()
{

})");
		}

		WHEN("Performing a partial compilation and forcing auto_binding resolve")
		{
			nzsl::Ast::BindingResolverTransformer::Options bindingResolverOpt;
			bindingResolverOpt.forceAutoBindingResolve = true;

			ResolveOptions resolveOptions;
			resolveOptions.partialCompilation = true;
			resolveOptions.bindingResolverOptions = &bindingResolverOpt;

			ResolveModule(*shaderModule, resolveOptions);

			ExpectNZSL(*shaderModule, R"(
struct Foo
{

}

[auto_binding(true)]
external
{
	[set(0), binding(1)] tex1: sampler2D[f32],
	[set(0), binding(2)] tex2: sampler2D[f32],
	foo: push_constant[Foo],
	[set(0), binding(4)] tex3: sampler2D[f32],
	[set(0), binding(0)] tex4: sampler2D[f32]
}

[auto_binding(true)]
external
{
	[set(0), binding(5)] tex5: array[sampler2D[f32], 3],
	[set(0), binding(3)] tex6: sampler_cube[f32]
}

[auto_binding(false)]
external
{
	[set(0), binding(8)] tex7: sampler2D[f32]
}

[entry(frag)]
fn main()
{

})");
		}
	}

	SECTION("Push constant generation")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[layout(std140)]
struct Data
{
	index: i32
}

external
{
	data: push_constant[Data]
}

[entry(frag)]
fn main()
{
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
layout(std140) uniform _nzslPushConstant
{
	int index;
} data;

void main()
{

}
)");

		ExpectNZSL(*shaderModule, R"(
struct Data
{
	index: i32
}

external
{
	data: push_constant[Data]
}

[entry(frag)]
fn main()
{

})");

	ExpectSPIRV(*shaderModule, R"(
     OpSource SourceLanguage(NZSL) 4198400
     OpSourceExtension "Version: 1.1"
     OpName %2 "Data"
     OpMemberName %2 0 "index"
     OpName %4 "data"
     OpName %7 "main"
     OpDecorate %2 Decoration(Block)
     OpMemberDecorate %2 0 Decoration(Offset) 0
%1 = OpTypeInt 32 1
%2 = OpTypeStruct %1
%3 = OpTypePointer StorageClass(PushConstant) %2
%5 = OpTypeVoid
%6 = OpTypeFunction %5
%4 = OpVariable %3 StorageClass(PushConstant)
%7 = OpFunction %5 FunctionControl(0) %6
%8 = OpLabel
     OpReturn
     OpFunctionEnd)", {}, {}, true);

		nzsl::WgslWriter::Environment wgslEnv;
		wgslEnv.featuresCallback = [](std::string_view) { return true; };

		ExpectWGSL(*shaderModule, R"(
// std140 layout
struct Data
{
	index: i32,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32
}

var<push_constant> data: Data;

@fragment
fn main()
{

}
)", {}, wgslEnv);
	}


	SECTION("Incompatible structs test")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

const MaxLightCascadeCount = 4;
const MaxLightCount = 3;

[layout(std140)]
struct DirectionalLight
{
	color: vec3[f32],
	direction: vec3[f32],
	invShadowMapSize: vec2[f32],	
	ambientFactor: f32,
	diffuseFactor: f32,
	cascadeCount: u32,
	cascadeDistances: array[f32, MaxLightCascadeCount],
	viewProjMatrices: array[mat4[f32], MaxLightCascadeCount],
}

[layout(std140)]
struct LightData
{
	directionalLights: array[DirectionalLight, MaxLightCount],
	directionalLightCount: u32
}

external
{
	[binding(0)] lightData: uniform[LightData]
}

[entry(frag)]
fn main()
{
	for lightIndex in u32(0) -> lightData.directionalLightCount
	{
		// light struct is not compatible with DirectionalLight (because of the ArrayStride), this forces a per-member copy in SPIR-V
		let light = lightData.directionalLights[lightIndex];

		// struct are compatibles, a direct copy is performed
		let lightCopy = light;
	}
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);

		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
struct DirectionalLight
{
	vec3 color;
	vec3 direction;
	vec2 invShadowMapSize;
	float ambientFactor;
	float diffuseFactor;
	uint cascadeCount;
	float cascadeDistances[4];
	mat4 viewProjMatrices[4];
};

// struct LightData omitted (used as UBO/SSBO)

layout(std140) uniform _nzslBindinglightData
{
	DirectionalLight directionalLights[3];
	uint directionalLightCount;
} lightData;

void main()
{
	{
		uint lightIndex = 0u;
		uint _nzsl_to = lightData.directionalLightCount;
		while (lightIndex < _nzsl_to)
		{
			DirectionalLight light;
			light.color = lightData.directionalLights[lightIndex].color;
			light.direction = lightData.directionalLights[lightIndex].direction;
			light.invShadowMapSize = lightData.directionalLights[lightIndex].invShadowMapSize;
			light.ambientFactor = lightData.directionalLights[lightIndex].ambientFactor;
			light.diffuseFactor = lightData.directionalLights[lightIndex].diffuseFactor;
			light.cascadeCount = lightData.directionalLights[lightIndex].cascadeCount;
			light.cascadeDistances = lightData.directionalLights[lightIndex].cascadeDistances;
			light.viewProjMatrices = lightData.directionalLights[lightIndex].viewProjMatrices;
			DirectionalLight lightCopy = light;
			lightIndex += 1u;
		}

	}

}
)");

		ExpectNZSL(*shaderModule, R"(
const MaxLightCascadeCount: i32 = 4;

const MaxLightCount: i32 = 3;

[layout(std140)]
struct DirectionalLight
{
	color: vec3[f32],
	direction: vec3[f32],
	invShadowMapSize: vec2[f32],
	ambientFactor: f32,
	diffuseFactor: f32,
	cascadeCount: u32,
	cascadeDistances: array[f32, 4],
	viewProjMatrices: array[mat4[f32], 4]
}

[layout(std140)]
struct LightData
{
	directionalLights: array[DirectionalLight, 3],
	directionalLightCount: u32
}

external
{
	[set(0), binding(0)] lightData: uniform[LightData]
}

[entry(frag)]
fn main()
{
	for lightIndex in u32(0) -> lightData.directionalLightCount
	{
		let light: DirectionalLight = lightData.directionalLights[lightIndex];
		let lightCopy: DirectionalLight = light;
	}

})");

		ExpectSPIRV(*shaderModule, R"(
 %37 = OpFunction %16 FunctionControl(0) %17
 %38 = OpLabel
 %39 = OpVariable %19 StorageClass(Function)
 %40 = OpVariable %19 StorageClass(Function)
 %41 = OpVariable %26 StorageClass(Function)
 %42 = OpVariable %26 StorageClass(Function)
       OpStore %39 %18
 %44 = OpAccessChain %43 %15 %21
 %45 = OpLoad %4 %44
       OpStore %40 %45
       OpBranch %46
 %46 = OpLabel
 %50 = OpLoad %4 %39
 %51 = OpLoad %4 %40
 %52 = OpULessThan %22 %50 %51
       OpLoopMerge %48 %49 LoopControl(0)
       OpBranchConditional %52 %47 %48
 %47 = OpLabel
 %53 = OpLoad %4 %39
 %55 = OpAccessChain %54 %15 %27 %53 %27
 %56 = OpLoad %2 %55
 %57 = OpAccessChain %58 %41 %27
       OpStore %57 %56
 %59 = OpLoad %4 %39
 %60 = OpAccessChain %54 %15 %27 %59 %21
 %61 = OpLoad %2 %60
 %62 = OpAccessChain %58 %41 %21
       OpStore %62 %61
 %63 = OpLoad %4 %39
 %65 = OpAccessChain %64 %15 %27 %63 %30
 %66 = OpLoad %3 %65
 %67 = OpAccessChain %68 %41 %30
       OpStore %67 %66
 %69 = OpLoad %4 %39
 %71 = OpAccessChain %70 %15 %27 %69 %31
 %72 = OpLoad %1 %71
 %73 = OpAccessChain %74 %41 %31
       OpStore %73 %72
 %75 = OpLoad %4 %39
 %76 = OpAccessChain %70 %15 %27 %75 %32
 %77 = OpLoad %1 %76
 %78 = OpAccessChain %74 %41 %32
       OpStore %78 %77
 %79 = OpLoad %4 %39
 %80 = OpAccessChain %43 %15 %27 %79 %33
 %81 = OpLoad %4 %80
 %82 = OpAccessChain %19 %41 %33
       OpStore %82 %81
 %83 = OpLoad %4 %39
 %84 = OpAccessChain %70 %15 %27 %83 %34 %27
 %85 = OpLoad %1 %84
 %86 = OpAccessChain %87 %41 %34
 %88 = OpAccessChain %74 %86 %27
       OpStore %88 %85
 %89 = OpLoad %4 %39
 %90 = OpAccessChain %70 %15 %27 %89 %34 %21
 %91 = OpLoad %1 %90
 %92 = OpAccessChain %87 %41 %34
 %93 = OpAccessChain %74 %92 %21
       OpStore %93 %91
 %94 = OpLoad %4 %39
 %95 = OpAccessChain %70 %15 %27 %94 %34 %30
 %96 = OpLoad %1 %95
 %97 = OpAccessChain %87 %41 %34
 %98 = OpAccessChain %74 %97 %30
       OpStore %98 %96
 %99 = OpLoad %4 %39
%100 = OpAccessChain %70 %15 %27 %99 %34 %31
%101 = OpLoad %1 %100
%102 = OpAccessChain %87 %41 %34
%103 = OpAccessChain %74 %102 %31
       OpStore %103 %101
%104 = OpLoad %4 %39
%106 = OpAccessChain %105 %15 %27 %104 %35 %27
%107 = OpLoad %8 %106
%108 = OpAccessChain %109 %41 %35
%110 = OpAccessChain %111 %108 %27
       OpStore %110 %107
%112 = OpLoad %4 %39
%113 = OpAccessChain %105 %15 %27 %112 %35 %21
%114 = OpLoad %8 %113
%115 = OpAccessChain %109 %41 %35
%116 = OpAccessChain %111 %115 %21
       OpStore %116 %114
%117 = OpLoad %4 %39
%118 = OpAccessChain %105 %15 %27 %117 %35 %30
%119 = OpLoad %8 %118
%120 = OpAccessChain %109 %41 %35
%121 = OpAccessChain %111 %120 %30
       OpStore %121 %119
%122 = OpLoad %4 %39
%123 = OpAccessChain %105 %15 %27 %122 %35 %31
%124 = OpLoad %8 %123
%125 = OpAccessChain %109 %41 %35
%126 = OpAccessChain %111 %125 %31
       OpStore %126 %124
%127 = OpLoad %25 %41
       OpStore %42 %127
%128 = OpLoad %4 %39
%129 = OpIAdd %4 %128 %36
       OpStore %39 %129
       OpBranch %49
 %49 = OpLabel
       OpBranch %46
 %48 = OpLabel
       OpReturn
       OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
struct f32_stride16
{
	value: f32,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32
}

// std140 layout
struct DirectionalLight
{
	color: vec3<f32>,
	direction: vec3<f32>,
	invShadowMapSize: vec2<f32>,
	ambientFactor: f32,
	diffuseFactor: f32,
	cascadeCount: u32,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32,
	cascadeDistances: array<f32_stride16, 4>,
	viewProjMatrices: array<mat4x4<f32>, 4>,
	_padding3: f32,
	_padding4: f32
}

// std140 layout
struct LightData
{
	directionalLights: array<DirectionalLight, 3>,
	directionalLightCount: u32,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32
}

@group(0) @binding(0) var<uniform> lightData: LightData;

@fragment
fn main()
{
	{
		var lightIndex: u32 = 0u;
		var _nzsl_to: u32 = lightData.directionalLightCount;
		while (lightIndex < _nzsl_to)
		{
			var light: DirectionalLight;
			light.color = lightData.directionalLights[lightIndex].color;
			light.direction = lightData.directionalLights[lightIndex].direction;
			light.invShadowMapSize = lightData.directionalLights[lightIndex].invShadowMapSize;
			light.ambientFactor = lightData.directionalLights[lightIndex].ambientFactor;
			light.diffuseFactor = lightData.directionalLights[lightIndex].diffuseFactor;
			light.cascadeCount = lightData.directionalLights[lightIndex].cascadeCount;
			light.cascadeDistances = lightData.directionalLights[lightIndex].cascadeDistances;
			light.cascadeDistances = lightData.directionalLights[lightIndex].cascadeDistances;
			var lightCopy: DirectionalLight = light;
			lightIndex += 1u;
		}

	}

}
)");
	}

	SECTION("named external")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[layout(std140)]
struct Data
{
	color: vec4[f32]
}

external Instance
{
	[tag("Color map")]
	[binding(0)] tex: sampler2D[f32],
	[binding(1)] data: uniform[Data]
}

[entry(frag)]
fn main()
{
	let value = Instance.tex.Sample(vec2[f32](0.0, 0.0)) * Instance.data.color;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// struct Data omitted (used as UBO/SSBO)

// external var tag: Color map
uniform sampler2D Instance_tex;
layout(std140) uniform _nzslBindingInstance_data
{
	vec4 color;
} Instance_data;

void main()
{
	vec4 value = (texture(Instance_tex, vec2(0.0, 0.0))) * Instance_data.color;
}
)");

		ExpectNZSL(*shaderModule, R"(
[layout(std140)]
struct Data
{
	color: vec4[f32]
}

external Instance
{
	[set(0), binding(0), tag("Color map")] tex: sampler2D[f32],
	[set(0), binding(1)] data: uniform[Data]
}

[entry(frag)]
fn main()
{
	let value: vec4[f32] = (Instance.tex.Sample(vec2[f32](0.0, 0.0))) * Instance.data.color;
})");

		ExpectSPIRV(*shaderModule, R"(
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 0 0 0 1 ImageFormat(Unknown)
 %3 = OpTypeSampledImage %2
 %4 = OpTypePointer StorageClass(UniformConstant) %3
 %6 = OpTypeVector %1 4
 %7 = OpTypeStruct %6
 %8 = OpTypePointer StorageClass(Uniform) %7
%10 = OpTypeVoid
%11 = OpTypeFunction %10
%12 = OpConstant %1 f32(0)
%13 = OpTypeVector %1 2
%14 = OpTypeInt 32 1
%15 = OpConstant %14 i32(0)
%16 = OpTypePointer StorageClass(Function) %6
%23 = OpTypePointer StorageClass(Uniform) %6
 %5 = OpVariable %4 StorageClass(UniformConstant)
 %9 = OpVariable %8 StorageClass(Uniform)
%17 = OpFunction %10 FunctionControl(0) %11
%18 = OpLabel
%19 = OpVariable %16 StorageClass(Function)
%20 = OpLoad %3 %5
%21 = OpCompositeConstruct %13 %12 %12
%22 = OpImageSampleImplicitLod %6 %20 %21
%24 = OpAccessChain %23 %9 %15
%25 = OpLoad %6 %24
%26 = OpFMul %6 %22 %25
      OpStore %19 %26
      OpReturn
      OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
// std140 layout
struct Data
{
	color: vec4<f32>
}

// Tag: Color map
@group(0) @binding(0) var Instance_tex: texture_2d<f32>;
@group(0) @binding(1) var Instance_texSampler: sampler;
@group(0) @binding(2) var<uniform> Instance_data: Data;

@fragment
fn main()
{
	var value: vec4<f32> = (textureSample(Instance_tex, Instance_texSampler, vec2<f32>(0.0, 0.0))) * Instance_data.color;
}
)");
	}

	SECTION("named external shadowing")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

external Viewer
{
	[tag("Color map")]
	[binding(0)] tex: sampler2D[f32]
}

[entry(frag)]
fn main()
{
	let Viewer_tex = 0.0;
	let value = Viewer_tex;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// fragment shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
precision highp sampler2D;
#else
precision mediump float;
precision mediump sampler2D;
#endif

// header end

// external var tag: Color map
uniform sampler2D Viewer_tex;

void main()
{
	float Viewer_tex_2 = 0.0;
	float value = Viewer_tex_2;
}
)");

		ExpectNZSL(*shaderModule, R"(
external Viewer
{
	[set(0), binding(0), tag("Color map")] tex: sampler2D[f32]
}

[entry(frag)]
fn main()
{
	let Viewer_tex: f32 = 0.0;
	let value: f32 = Viewer_tex;
})");

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %10 "main"
      OpExecutionMode %10 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %5 "Viewer_tex"
      OpName %10 "main"
      OpDecorate %5 Decoration(Binding) 0
      OpDecorate %5 Decoration(DescriptorSet) 0
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 0 0 0 1 ImageFormat(Unknown)
 %3 = OpTypeSampledImage %2
 %4 = OpTypePointer StorageClass(UniformConstant) %3
 %6 = OpTypeVoid
 %7 = OpTypeFunction %6
 %8 = OpConstant %1 f32(0)
 %9 = OpTypePointer StorageClass(Function) %1
 %5 = OpVariable %4 StorageClass(UniformConstant)
%10 = OpFunction %6 FunctionControl(0) %7
%11 = OpLabel
%12 = OpVariable %9 StorageClass(Function)
%13 = OpVariable %9 StorageClass(Function)
      OpStore %12 %8
%14 = OpLoad %1 %12
      OpStore %13 %14
      OpReturn
      OpFunctionEnd)", {}, {}, true);

		ExpectWGSL(*shaderModule, R"(
// Tag: Color map
@group(0) @binding(0) var Viewer_tex: texture_2d<f32>;
@group(0) @binding(1) var Viewer_texSampler: sampler;

@fragment
fn main()
{
	var Viewer_tex: f32 = 0.0;
	var value: f32 = Viewer_tex;
}
)");
	}

	SECTION("Proper SPIR-V 1.4 generation")
	{
		// Starting with SPIR-V 1.4, an entry point has to list all external resources used
		std::string_view nzslSource = R"(
[nzsl_version("1.1")]
module;

[layout(std140)]
struct MaterialData
{
	color: vec4[f32]
}

[layout(std140)]
struct InstanceData
{
	worldViewProjMat: mat4[f32]
}

external
{
	[binding(0)] tex: sampler2D[f32],
	[binding(1)] instanceData: uniform[InstanceData],
	[binding(2)] materialData: uniform[MaterialData]
}

struct VertIn
{
	[location(0)] pos: vec3[f32],
	[location(1)] uv: vec2[f32]
}

struct VertOut
{
	[builtin(position)] pos: vec4[f32],
	[location(0)] uv: vec2[f32]
}

struct FragOut
{
	[location(0)] color: vec4[f32]
}

fn GetBaseColor() -> vec4[f32]
{
	return materialData.color;
}

fn GetWorldMatrix() -> mat4[f32]
{
	return Intermediate();
}

fn Intermediate() -> mat4[f32]
{
	return instanceData.worldViewProjMat;
}

[entry(frag)]
fn main(input: VertOut) -> FragOut
{
	let output: FragOut;
	output.color = GetBaseColor() * tex.Sample(input.uv);

	return output;
}

[entry(vert)]
fn main(input: VertIn) -> VertOut
{
	let output: VertOut;
	output.pos = GetWorldMatrix() * vec4[f32](input.pos, 1.0);
	output.uv = input.uv;

	return output;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		ResolveModule(*shaderModule);

		ExpectGLSL(nzsl::ShaderStageType::Fragment, *shaderModule, R"(
// struct MaterialData omitted (used as UBO/SSBO)

// struct InstanceData omitted (used as UBO/SSBO)

uniform sampler2D tex;
layout(std140) uniform _nzslBindinginstanceData
{
	mat4 worldViewProjMat;
} instanceData;

layout(std140) uniform _nzslBindingmaterialData
{
	vec4 color;
} materialData;

struct VertIn
{
	vec3 pos;
	vec2 uv;
};

struct VertOut
{
	vec4 pos;
	vec2 uv;
};

struct FragOut
{
	vec4 color;
};

vec4 GetBaseColor()
{
	return materialData.color;
}

mat4 Intermediate();

mat4 GetWorldMatrix()
{
	return Intermediate();
}

mat4 Intermediate()
{
	return instanceData.worldViewProjMat;
}

/**************** Inputs ****************/
in vec2 _nzslVarying0; // _nzslInuv

/*************** Outputs ***************/
layout(location = 0) out vec4 _nzslOutcolor;

void main()
{
	VertOut input_;
	input_.uv = _nzslVarying0;

	FragOut output_;
	output_.color = (GetBaseColor()) * (texture(tex, input_.uv));

	_nzslOutcolor = output_.color;
	return;
}
)");

		ExpectGLSL(nzsl::ShaderStageType::Vertex, *shaderModule, R"(
// struct MaterialData omitted (used as UBO/SSBO)

// struct InstanceData omitted (used as UBO/SSBO)

uniform sampler2D tex;
layout(std140) uniform _nzslBindinginstanceData
{
	mat4 worldViewProjMat;
} instanceData;

layout(std140) uniform _nzslBindingmaterialData
{
	vec4 color;
} materialData;

struct VertIn
{
	vec3 pos;
	vec2 uv;
};

struct VertOut
{
	vec4 pos;
	vec2 uv;
};

struct FragOut
{
	vec4 color;
};

vec4 GetBaseColor()
{
	return materialData.color;
}

mat4 Intermediate();

mat4 GetWorldMatrix()
{
	return Intermediate();
}

mat4 Intermediate()
{
	return instanceData.worldViewProjMat;
}

/**************** Inputs ****************/
layout(location = 0) in vec3 _nzslInpos;
layout(location = 1) in vec2 _nzslInuv;

/*************** Outputs ***************/
out vec2 _nzslVarying0; // _nzslOutuv

void main()
{
	VertIn input_;
	input_.pos = _nzslInpos;
	input_.uv = _nzslInuv;

	VertOut output_;
	output_.pos = (GetWorldMatrix()) * (vec4(input_.pos, 1.0));
	output_.uv = input_.uv;

	gl_Position = output_.pos;
	_nzslVarying0 = output_.uv;
	return;
}
)");

		ExpectNZSL(*shaderModule, R"(
[nzsl_version("1.1")]
module;

[layout(std140)]
struct MaterialData
{
	color: vec4[f32]
}

[layout(std140)]
struct InstanceData
{
	worldViewProjMat: mat4[f32]
}

external
{
	[set(0), binding(0)] tex: sampler2D[f32],
	[set(0), binding(1)] instanceData: uniform[InstanceData],
	[set(0), binding(2)] materialData: uniform[MaterialData]
}

struct VertIn
{
	[location(0)] pos: vec3[f32],
	[location(1)] uv: vec2[f32]
}

struct VertOut
{
	[builtin(position)] pos: vec4[f32],
	[location(0)] uv: vec2[f32]
}

struct FragOut
{
	[location(0)] color: vec4[f32]
}

fn GetBaseColor() -> vec4[f32]
{
	return materialData.color;
}

fn GetWorldMatrix() -> mat4[f32]
{
	return Intermediate();
}

fn Intermediate() -> mat4[f32]
{
	return instanceData.worldViewProjMat;
}

[entry(frag)]
fn main(input: VertOut) -> FragOut
{
	let output: FragOut;
	output.color = (GetBaseColor()) * (tex.Sample(input.uv));
	return output;
}

[entry(vert)]
fn main(input: VertIn) -> VertOut
{
	let output: VertOut;
	output.pos = (GetWorldMatrix()) * (vec4[f32](input.pos, 1.0));
	output.uv = input.uv;
	return output;
})");

		nzsl::SpirvWriter::Environment env;
		env.spvMajorVersion = 1;
		env.spvMinorVersion = 4;

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %45 "main" %22 %28 %5 %13
      OpEntryPoint ExecutionModel(Vertex) %46 "main" %33 %35 %38 %40 %10
      OpExecutionMode %45 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 4198400
      OpSourceExtension "Version: 1.1"
      OpName %8 "InstanceData"
      OpMemberName %8 0 "worldViewProjMat"
      OpName %11 "MaterialData"
      OpMemberName %11 0 "color"
      OpName %25 "VertOut"
      OpMemberName %25 0 "pos"
      OpMemberName %25 1 "uv"
      OpName %29 "FragOut"
      OpMemberName %29 0 "color"
      OpName %36 "VertIn"
      OpMemberName %36 0 "pos"
      OpMemberName %36 1 "uv"
      OpName %5 "tex"
      OpName %10 "instanceData"
      OpName %13 "materialData"
      OpName %22 "uv"
      OpName %28 "color"
      OpName %33 "pos"
      OpName %35 "uv"
      OpName %38 "position"
      OpName %40 "uv"
      OpName %42 "GetBaseColor"
      OpName %43 "GetWorldMatrix"
      OpName %44 "Intermediate"
      OpName %45 "main"
      OpName %46 "main"
      OpDecorate %5 Decoration(Binding) 0
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %10 Decoration(Binding) 1
      OpDecorate %10 Decoration(DescriptorSet) 0
      OpDecorate %13 Decoration(Binding) 2
      OpDecorate %13 Decoration(DescriptorSet) 0
      OpDecorate %38 Decoration(BuiltIn) BuiltIn(Position)
      OpDecorate %22 Decoration(Location) 0
      OpDecorate %28 Decoration(Location) 0
      OpDecorate %33 Decoration(Location) 0
      OpDecorate %35 Decoration(Location) 1
      OpDecorate %40 Decoration(Location) 0
      OpDecorate %8 Decoration(Block)
      OpMemberDecorate %8 0 Decoration(ColMajor)
      OpMemberDecorate %8 0 Decoration(MatrixStride) 16
      OpMemberDecorate %8 0 Decoration(Offset) 0
      OpDecorate %11 Decoration(Block)
      OpMemberDecorate %11 0 Decoration(Offset) 0
      OpMemberDecorate %25 0 Decoration(Offset) 0
      OpMemberDecorate %25 1 Decoration(Offset) 16
      OpMemberDecorate %29 0 Decoration(Offset) 0
      OpMemberDecorate %36 0 Decoration(Offset) 0
      OpMemberDecorate %36 1 Decoration(Offset) 16
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 0 0 0 1 ImageFormat(Unknown)
 %3 = OpTypeSampledImage %2
 %4 = OpTypePointer StorageClass(UniformConstant) %3
 %6 = OpTypeVector %1 4
 %7 = OpTypeMatrix %6 4
 %8 = OpTypeStruct %7
 %9 = OpTypePointer StorageClass(Uniform) %8
%11 = OpTypeStruct %6
%12 = OpTypePointer StorageClass(Uniform) %11
%14 = OpTypeFunction %6
%15 = OpTypeInt 32 1
%16 = OpConstant %15 i32(0)
%17 = OpTypeFunction %7
%18 = OpTypeVoid
%19 = OpTypeFunction %18
%20 = OpTypeVector %1 2
%21 = OpTypePointer StorageClass(Input) %20
%23 = OpConstant %15 i32(1)
%24 = OpTypePointer StorageClass(Function) %20
%25 = OpTypeStruct %6 %20
%26 = OpTypePointer StorageClass(Function) %25
%27 = OpTypePointer StorageClass(Output) %6
%29 = OpTypeStruct %6
%30 = OpTypePointer StorageClass(Function) %29
%31 = OpTypeVector %1 3
%32 = OpTypePointer StorageClass(Input) %31
%34 = OpTypePointer StorageClass(Function) %31
%36 = OpTypeStruct %31 %20
%37 = OpTypePointer StorageClass(Function) %36
%39 = OpTypePointer StorageClass(Output) %20
%41 = OpConstant %1 f32(1)
%48 = OpTypePointer StorageClass(Uniform) %6
%54 = OpTypePointer StorageClass(Uniform) %7
%68 = OpTypePointer StorageClass(Function) %6
 %5 = OpVariable %4 StorageClass(UniformConstant)
%10 = OpVariable %9 StorageClass(Uniform)
%13 = OpVariable %12 StorageClass(Uniform)
%22 = OpVariable %21 StorageClass(Input)
%28 = OpVariable %27 StorageClass(Output)
%33 = OpVariable %32 StorageClass(Input)
%35 = OpVariable %21 StorageClass(Input)
%38 = OpVariable %27 StorageClass(Output)
%40 = OpVariable %39 StorageClass(Output)
%42 = OpFunction %6 FunctionControl(0) %14
%47 = OpLabel
%49 = OpAccessChain %48 %13 %16
%50 = OpLoad %6 %49
      OpReturnValue %50
      OpFunctionEnd
%43 = OpFunction %7 FunctionControl(0) %17
%51 = OpLabel
%52 = OpFunctionCall %7 %44
      OpReturnValue %52
      OpFunctionEnd
%44 = OpFunction %7 FunctionControl(0) %17
%53 = OpLabel
%55 = OpAccessChain %54 %10 %16
%56 = OpLoad %7 %55
      OpReturnValue %56
      OpFunctionEnd
%45 = OpFunction %18 FunctionControl(0) %19
%57 = OpLabel
%58 = OpVariable %30 StorageClass(Function)
%59 = OpVariable %26 StorageClass(Function)
%60 = OpAccessChain %24 %59 %23
      OpCopyMemory %60 %22
%61 = OpFunctionCall %6 %42
%62 = OpLoad %3 %5
%63 = OpAccessChain %24 %59 %23
%64 = OpLoad %20 %63
%65 = OpImageSampleImplicitLod %6 %62 %64
%66 = OpFMul %6 %61 %65
%67 = OpAccessChain %68 %58 %16
      OpStore %67 %66
%69 = OpLoad %29 %58
%70 = OpCompositeExtract %6 %69 0
      OpStore %28 %70
      OpReturn
      OpFunctionEnd
%46 = OpFunction %18 FunctionControl(0) %19
%71 = OpLabel
%72 = OpVariable %26 StorageClass(Function)
%73 = OpVariable %37 StorageClass(Function)
%74 = OpAccessChain %34 %73 %16
      OpCopyMemory %74 %33
%75 = OpAccessChain %24 %73 %23
      OpCopyMemory %75 %35
%76 = OpFunctionCall %7 %43
%77 = OpAccessChain %34 %73 %16
%78 = OpLoad %31 %77
%79 = OpCompositeConstruct %6 %78 %41
%80 = OpMatrixTimesVector %6 %76 %79
%81 = OpAccessChain %68 %72 %16
      OpStore %81 %80
%82 = OpAccessChain %24 %73 %23
%83 = OpLoad %20 %82
%84 = OpAccessChain %24 %72 %23
      OpStore %84 %83
%85 = OpLoad %25 %72
%86 = OpCompositeExtract %6 %85 0
      OpStore %38 %86
%87 = OpCompositeExtract %20 %85 1
      OpStore %40 %87
      OpReturn
      OpFunctionEnd)", {}, env, true);

		ExpectWGSL(*shaderModule, R"(
// std140 layout
struct MaterialData
{
	color: vec4<f32>
}

// std140 layout
struct InstanceData
{
	worldViewProjMat: mat4x4<f32>,
	_padding0: f32,
	_padding1: f32,
	_padding2: f32
}

@group(0) @binding(0) var tex: texture_2d<f32>;
@group(0) @binding(1) var texSampler: sampler;
@group(0) @binding(2) var<uniform> instanceData: InstanceData;
@group(0) @binding(3) var<uniform> materialData: MaterialData;

struct VertIn
{
	@location(0) pos: vec3<f32>,
	@location(1) uv: vec2<f32>
}

struct VertOut
{
	@builtin(position) pos: vec4<f32>,
	@location(0) uv: vec2<f32>
}

struct FragOut
{
	@location(0) color: vec4<f32>
}

fn GetBaseColor() -> vec4<f32>
{
	return materialData.color;
}

fn GetWorldMatrix() -> mat4x4<f32>
{
	return Intermediate();
}

fn Intermediate() -> mat4x4<f32>
{
	return instanceData.worldViewProjMat;
}

@fragment
fn main(input: VertOut) -> FragOut
{
	var output: FragOut;
	output.color = (GetBaseColor()) * (textureSample(tex, texSampler, input.uv));
	return output;
}

@vertex
fn main_2(input: VertIn) -> VertOut
{
	var output: VertOut;
	output.pos = (GetWorldMatrix()) * (vec4<f32>(input.pos, 1.0));
	output.uv = input.uv;
	return output;
}
)");
	}
}
