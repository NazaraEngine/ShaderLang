#include <Tests/ShaderUtils.hpp>
#include <NZSL/ShaderBuilder.hpp>
#include <NZSL/Parser.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers.hpp>
#include <cctype>

TEST_CASE("layout", "[Shader]")
{
	SECTION("std140")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.0")]
module;

[layout(std140)]
struct Foo
{
	v0: vec3[f32],
	v1: vec3[f32],
	v2: f32,
}

external
{
	[binding(0)] foo: uniform[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		shaderModule = SanitizeModule(*shaderModule);

		ExpectGLSL(*shaderModule, R"(
// fragment shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

// header end

// struct Foo omitted (used as UBO/SSBO)

layout(std140) uniform _nzslBindingfoo
{
	vec3 v0;
	vec3 v1;
	float v2;
} foo;

void main()
{
	float value = 0.0;
}
)");

		ExpectNZSL(*shaderModule, R"(
[layout(std140)]
struct Foo
{
	v0: vec3[f32],
	v1: vec3[f32],
	v2: f32
}

external
{
	[set(0), binding(0)] foo: uniform[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)");

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %10 "main"
      OpExecutionMode %10 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 100
      OpName %3 "Foo"
      OpMemberName %3 0 "v0"
      OpMemberName %3 1 "v1"
      OpMemberName %3 2 "v2"
      OpName %5 "foo"
      OpName %10 "main"
      OpDecorate %5 Decoration(Binding) 0
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %3 Decoration(Block)
      OpMemberDecorate %3 0 Decoration(Offset) 0
      OpMemberDecorate %3 1 Decoration(Offset) 16
      OpMemberDecorate %3 2 Decoration(Offset) 28
 %1 = OpTypeFloat 32
 %2 = OpTypeVector %1 3
 %3 = OpTypeStruct %2 %2 %1
 %4 = OpTypePointer StorageClass(Uniform) %3
 %6 = OpTypeVoid
 %7 = OpTypeFunction %6
 %8 = OpConstant %1 f32(0)
 %9 = OpTypePointer StorageClass(Function) %1
 %5 = OpVariable %4 StorageClass(Uniform)
%10 = OpFunction %6 FunctionControl(0) %7
%11 = OpLabel
%12 = OpVariable %9 StorageClass(Function)
      OpStore %12 %8
      OpReturn
      OpFunctionEnd
)", {}, {}, true);
	}

	SECTION("std430")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.0")]
module;

[layout(std430)]
struct Bar
{
	v0: vec2[f32],
}

[layout(std430)]
struct Foo
{
	v0: f32,
	v1: vec3[f32],
	v2: array[f32, 4],
	v3: vec2[f32],
	v4: Bar,
	v5: vec3[f32],
	v6: f32,
}

external
{
	[binding(0)] foo: storage[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		shaderModule = SanitizeModule(*shaderModule);

		nzsl::GlslWriter::Environment glslEnv;
		glslEnv.glMajorVersion = 4;
		glslEnv.glMinorVersion = 5;
		glslEnv.glES = false;

		ExpectGLSL(*shaderModule, R"(
#version 450

// fragment shader - this file was generated by NZSL compiler (Nazara Shading Language)

// header end

struct Bar
{
	vec2 v0;
};

// struct Foo omitted (used as UBO/SSBO)

layout(std430) buffer _nzslBindingfoo
{
	float v0;
	vec3 v1;
	float v2[4];
	vec2 v3;
	Bar v4;
	vec3 v5;
	float v6;
} foo;

void main()
{
	float value = 0.0;
}
)", {}, glslEnv);

		ExpectNZSL(*shaderModule, R"(
[nzsl_version("1.0")]
module;

[layout(std430)]
struct Bar
{
	v0: vec2[f32]
}

[layout(std430)]
struct Foo
{
	v0: f32,
	v1: vec3[f32],
	v2: array[f32, 4],
	v3: vec2[f32],
	v4: Bar,
	v5: vec3[f32],
	v6: f32
}

external
{
	[set(0), binding(0)] foo: storage[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)");

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %15 "main"
      OpExecutionMode %15 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 100
      OpName %7 "Bar"
      OpMemberName %7 0 "v0"
      OpName %8 "Foo"
      OpMemberName %8 0 "v0"
      OpMemberName %8 1 "v1"
      OpMemberName %8 2 "v2"
      OpMemberName %8 3 "v3"
      OpMemberName %8 4 "v4"
      OpMemberName %8 5 "v5"
      OpMemberName %8 6 "v6"
      OpName %10 "foo"
      OpName %15 "main"
      OpDecorate %10 Decoration(Binding) 0
      OpDecorate %10 Decoration(DescriptorSet) 0
      OpDecorate %5 Decoration(ArrayStride) 4
      OpMemberDecorate %7 0 Decoration(Offset) 0
      OpDecorate %8 Decoration(BufferBlock)
      OpMemberDecorate %8 0 Decoration(Offset) 0
      OpMemberDecorate %8 1 Decoration(Offset) 16
      OpMemberDecorate %8 2 Decoration(Offset) 28
      OpMemberDecorate %8 3 Decoration(Offset) 48
      OpMemberDecorate %8 4 Decoration(Offset) 56
      OpMemberDecorate %8 5 Decoration(Offset) 64
      OpMemberDecorate %8 6 Decoration(Offset) 76
 %1 = OpTypeFloat 32
 %2 = OpTypeVector %1 3
 %3 = OpTypeInt 32 0
 %4 = OpConstant %3 u32(4)
 %5 = OpTypeArray %1 %4
 %6 = OpTypeVector %1 2
 %7 = OpTypeStruct %6
 %8 = OpTypeStruct %1 %2 %5 %6 %7 %2 %1
 %9 = OpTypePointer StorageClass(Uniform) %8
%11 = OpTypeVoid
%12 = OpTypeFunction %11
%13 = OpConstant %1 f32(0)
%14 = OpTypePointer StorageClass(Function) %1
%10 = OpVariable %9 StorageClass(Uniform)
%15 = OpFunction %11 FunctionControl(0) %12
%16 = OpLabel
%17 = OpVariable %14 StorageClass(Function)
      OpStore %17 %13
      OpReturn
      OpFunctionEnd
)", {}, {}, true);
	}

		SECTION("scalar")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.0")]
module;

[layout(scalar)]
struct Foo
{
	v0: vec3[f32],
	v1: vec3[f32]
}

external
{
	[binding(0)] foo: storage[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		shaderModule = SanitizeModule(*shaderModule);

		ExpectNZSL(*shaderModule, R"(
[layout(scalar)]
struct Foo
{
	v0: vec3[f32],
	v1: vec3[f32]
}

external
{
	[set(0), binding(0)] foo: storage[Foo]
}

[entry(frag)]
fn main()
{
	let value: f32 = 0.0;
}
)");
		spvtools::ValidatorOptions spvValidatorOptions;
		spvValidatorOptions.SetScalarBlockLayout(true);

		WHEN("Generating SPIR-V 1.0")
		{
			nzsl::SpirvWriter::Environment spirvEnv;
			spirvEnv.spvMajorVersion = 1;
			spirvEnv.spvMinorVersion = 0;

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %10 "main"
      OpExecutionMode %10 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 100
      OpName %3 "Foo"
      OpMemberName %3 0 "v0"
      OpMemberName %3 1 "v1"
      OpName %5 "foo"
      OpName %10 "main"
      OpDecorate %5 Decoration(Binding) 0
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %3 Decoration(BufferBlock)
      OpMemberDecorate %3 0 Decoration(Offset) 0
      OpMemberDecorate %3 1 Decoration(Offset) 12
 %1 = OpTypeFloat 32
 %2 = OpTypeVector %1 3
 %3 = OpTypeStruct %2 %2
 %4 = OpTypePointer StorageClass(Uniform) %3
 %6 = OpTypeVoid
 %7 = OpTypeFunction %6
 %8 = OpConstant %1 f32(0)
 %9 = OpTypePointer StorageClass(Function) %1
 %5 = OpVariable %4 StorageClass(Uniform)
%10 = OpFunction %6 FunctionControl(0) %7
%11 = OpLabel
%12 = OpVariable %9 StorageClass(Function)
      OpStore %12 %8
      OpReturn
      OpFunctionEnd
)", {}, spirvEnv, true, spvValidatorOptions);
		}

		WHEN("Generating SPIR-V 1.3")
		{
			nzsl::SpirvWriter::Environment spirvEnv;
			spirvEnv.spvMajorVersion = 1;
			spirvEnv.spvMinorVersion = 3;

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(Fragment) %10 "main"
      OpExecutionMode %10 ExecutionMode(OriginUpperLeft)
      OpSource SourceLanguage(NZSL) 100
      OpName %3 "Foo"
      OpMemberName %3 0 "v0"
      OpMemberName %3 1 "v1"
      OpName %5 "foo"
      OpName %10 "main"
      OpDecorate %5 Decoration(Binding) 0
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %3 Decoration(Block)
      OpMemberDecorate %3 0 Decoration(Offset) 0
      OpMemberDecorate %3 1 Decoration(Offset) 12
 %1 = OpTypeFloat 32
 %2 = OpTypeVector %1 3
 %3 = OpTypeStruct %2 %2
 %4 = OpTypePointer StorageClass(StorageBuffer) %3
 %6 = OpTypeVoid
 %7 = OpTypeFunction %6
 %8 = OpConstant %1 f32(0)
 %9 = OpTypePointer StorageClass(Function) %1
 %5 = OpVariable %4 StorageClass(StorageBuffer)
%10 = OpFunction %6 FunctionControl(0) %7
%11 = OpLabel
%12 = OpVariable %9 StorageClass(Function)
      OpStore %12 %8
      OpReturn
      OpFunctionEnd
)", {}, spirvEnv, true, spvValidatorOptions);
		}
	}

}
