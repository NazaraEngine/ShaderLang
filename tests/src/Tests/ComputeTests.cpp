#include <Tests/ShaderUtils.hpp>
#include <NZSL/ShaderBuilder.hpp>
#include <NZSL/Parser.hpp>
#include <catch2/catch_test_macros.hpp>
#include <cctype>

TEST_CASE("compute", "[Shader]")
{
	SECTION("Simple texture copy")
	{
		std::string_view nzslSource = R"(
[nzsl_version("1.0")]
module;

struct Data
{
	tex_size: vec2[u32]
}

[auto_binding]
external
{
	input_tex: texture2D[f32, readonly, rgba8],
	output_tex: texture2D[f32, writeonly, rgba8],
	data: uniform[Data]
}

struct Input
{
	[builtin(global_invocation_indices)] indices: vec3[u32]
}

[entry(compute)]
[workgroup(32, 16*2, 1)]
fn main(input: Input)
{
	if (input.indices.x >= data.tex_size.x || input.indices.y >= data.tex_size.y)
		return;

	let value = input_tex.Read(vec2[i32](input.indices.xy));
	output_tex.Write(vec2[i32](input.indices.xy), value);
}
)";

		nzsl::Ast::ModulePtr shaderModule = nzsl::Parse(nzslSource);
		shaderModule = SanitizeModule(*shaderModule);

		nzsl::GlslWriter::Environment glslEnv;
		glslEnv.glES = true;
		glslEnv.glMajorVersion = 3;
		glslEnv.glMinorVersion = 1;

		ExpectGLSL(*shaderModule, R"(
#version 310 es

// compute shader - this file was generated by NZSL compiler (Nazara Shading Language)

precision highp int;
#if GL_FRAGMENT_PRECISION_HIGH
precision highp float;
precision highp image2D;
#else
precision mediump float;
precision mediump image2D;
#endif

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// header end

// struct Data omitted (used as UBO/SSBO)

layout(rgba8) uniform readonly image2D input_tex;
layout(rgba8) uniform writeonly image2D output_tex;
uniform _nzslBindingdata
{
	uvec2 tex_size;
} data;

struct Input
{
	uvec3 indices;
};

void main()
{
	Input input_;
	input_.indices = gl_GlobalInvocationID;

	if ((input_.indices.x >= data.tex_size.x) || (input_.indices.y >= data.tex_size.y))
	{
		return;
	}

	vec4 value = imageLoad(input_tex, ivec2(input_.indices.xy));
	imageStore(output_tex, ivec2(input_.indices.xy), value);
})", {}, glslEnv);

		ExpectNZSL(*shaderModule, R"(
[nzsl_version("1.0")]
module;

struct Data
{
	tex_size: vec2[u32]
}

[auto_binding(true)]
external
{
	[set(0), binding(0)] input_tex: texture2D[f32, readonly, rgba8],
	[set(0), binding(1)] output_tex: texture2D[f32, writeonly, rgba8],
	[set(0), binding(2)] data: uniform[Data]
}

struct Input
{
	[builtin(global_invocation_indices)] indices: vec3[u32]
}

[entry(comp), workgroup(32, 32, 1)]
fn main(input: Input)
{
	if ((input.indices.x >= data.tex_size.x) || (input.indices.y >= data.tex_size.y))
	{
		return;
	}

	let value: vec4[f32] = input_tex.Read(vec2[i32](input.indices.xy));
	output_tex.Write(vec2[i32](input.indices.xy), value);
})");

		ExpectSPIRV(*shaderModule, R"(
      OpCapability Capability(Shader)
      OpMemoryModel AddressingModel(Logical) MemoryModel(GLSL450)
      OpEntryPoint ExecutionModel(GLCompute) %26 "main" %15
      OpExecutionMode %26 ExecutionMode(LocalSize) 32 32 1
      OpSource SourceLanguage(Unknown) 100
      OpName %8 "Data"
      OpMemberName %8 0 "tex_size"
      OpName %19 "Input"
      OpMemberName %19 0 "indices"
      OpName %4 "input_tex"
      OpName %5 "output_tex"
      OpName %10 "data"
      OpName %15 "global_invocation_indices"
      OpName %26 "main"
      OpDecorate %4 Decoration(Binding) 0
      OpDecorate %4 Decoration(DescriptorSet) 0
      OpDecorate %5 Decoration(Binding) 1
      OpDecorate %5 Decoration(DescriptorSet) 0
      OpDecorate %10 Decoration(Binding) 2
      OpDecorate %10 Decoration(DescriptorSet) 0
      OpDecorate %15 Decoration(BuiltIn) BuiltIn(GlobalInvocationId)
      OpDecorate %8 Decoration(Block)
      OpMemberDecorate %8 0 Decoration(Offset) 0
      OpMemberDecorate %19 0 Decoration(Offset) 0
 %1 = OpTypeFloat 32
 %2 = OpTypeImage %1 Dim(Dim2D) 2 0 0 2 ImageFormat(Rgba8)
 %3 = OpTypePointer StorageClass(UniformConstant) %2
 %6 = OpTypeInt 32 0
 %7 = OpTypeVector %6 2
 %8 = OpTypeStruct %7
 %9 = OpTypePointer StorageClass(Uniform) %8
%11 = OpTypeVoid
%12 = OpTypeFunction %11
%13 = OpTypeVector %6 3
%14 = OpTypePointer StorageClass(Input) %13
%16 = OpTypeInt 32 1
%17 = OpConstant %16 i32(0)
%18 = OpTypePointer StorageClass(Function) %13
%19 = OpTypeStruct %13
%20 = OpTypePointer StorageClass(Function) %19
%21 = OpTypeBool
%22 = OpConstant %16 i32(1)
%23 = OpTypeVector %16 2
%24 = OpTypeVector %1 4
%25 = OpTypePointer StorageClass(Function) %24
%37 = OpTypePointer StorageClass(Uniform) %7
 %4 = OpVariable %3 StorageClass(UniformConstant)
 %5 = OpVariable %3 StorageClass(UniformConstant)
%10 = OpVariable %9 StorageClass(Uniform)
%15 = OpVariable %14 StorageClass(Input)
%26 = OpFunction %11 FunctionControl(0) %12
%27 = OpLabel
%28 = OpVariable %25 StorageClass(Function)
%29 = OpVariable %20 StorageClass(Function)
%30 = OpAccessChain %18 %29 %17
      OpCopyMemory %30 %15
%34 = OpAccessChain %18 %29 %17
%35 = OpLoad %13 %34
%36 = OpCompositeExtract %6 %35 0
%38 = OpAccessChain %37 %10 %17
%39 = OpLoad %7 %38
%40 = OpCompositeExtract %6 %39 0
%41 = OpUGreaterThanEqual %21 %36 %40
%42 = OpAccessChain %18 %29 %17
%43 = OpLoad %13 %42
%44 = OpCompositeExtract %6 %43 1
%45 = OpAccessChain %37 %10 %17
%46 = OpLoad %7 %45
%47 = OpCompositeExtract %6 %46 1
%48 = OpUGreaterThanEqual %21 %44 %47
%49 = OpLogicalOr %21 %41 %48
      OpSelectionMerge %31 SelectionControl(0)
      OpBranchConditional %49 %32 %33
%32 = OpLabel
      OpReturn
%33 = OpLabel
      OpBranch %31
%31 = OpLabel
%50 = OpLoad %2 %4
%51 = OpAccessChain %18 %29 %17
%52 = OpLoad %13 %51
%53 = OpVectorShuffle %7 %52 %52 0 1
%54 = OpBitcast %23 %53
%55 = OpImageRead %24 %50 %54
      OpStore %28 %55
%56 = OpLoad %2 %5
%57 = OpAccessChain %18 %29 %17
%58 = OpLoad %13 %57
%59 = OpVectorShuffle %7 %58 %58 0 1
%60 = OpBitcast %23 %59
%61 = OpLoad %24 %28
      OpImageWrite %56 %60 %61
      OpReturn
      OpFunctionEnd)", {}, {}, true);
	}
}
